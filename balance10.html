<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒãƒ©ãƒ³ã‚¹ç©ã¿ä¸Šã’ã‚²ãƒ¼ãƒ </title>
  <style>
    body {
      background: #eef;
      margin: 0;
      overflow: hidden;
      text-align: center;
      font-family: sans-serif;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
      color: #333;
    }
  </style>
</head>
<body>
  <div id="score">ã‚¹ã‚³ã‚¢: 0ã€€ãƒŸã‚¹: 0/3</div>
  <canvas id="world"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, World, Bodies, Runner, Body, Events, Constraint } = Matter;

    const canvas = document.getElementById("world");
    const engine = Engine.create();
    const world = engine.world;
    const render = Render.create({
      canvas,
      engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "#eef"
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;

    // åœ°é¢ï¼ˆè¦‹ãˆãªã„ï¼‰
    const ground = Bodies.rectangle(WIDTH / 2, HEIGHT + 50, WIDTH, 100, { isStatic: true });
    World.add(world, ground);

    // å—ã‘çš¿ï¼ˆå¤§ããã¦ã‚†ã£ãã‚Šå‹•ãï¼‰
    const paddleWidth = 300;
    const paddleHeight = 20;
    const paddle = Bodies.rectangle(WIDTH / 2, HEIGHT - 100, paddleWidth, paddleHeight, {
      isStatic: true,
      render: { fillStyle: "#66c" }
    });
    World.add(world, paddle);

    let moveDirection = 1;
    const moveSpeed = 2; // ã‚†ã£ãã‚Šå‹•ã

    // ã‚¹ã‚³ã‚¢ã¨ãƒŸã‚¹å›æ•°
    let score = 0;
    let misses = 0;
    const maxMisses = 3;
    let gameOver = false;

    // ãƒ©ãƒ³ãƒ€ãƒ ãªå½¢ã‚’ç”Ÿæˆ
    function createRandomShape(x, y) {
      const size = 40 + Math.random() * 20;
      const type = Math.floor(Math.random() * 3); // 0:å››è§’, 1:ä¸¸, 2:ä¸‰è§’
      let body;
      const color = `hsl(${Math.random() * 360}, 70%, 60%)`;

      if (type === 0) {
        body = Bodies.rectangle(x, y, size, size, { restitution: 0.2, friction: 0.9, render: { fillStyle: color } });
      } else if (type === 1) {
        body = Bodies.circle(x, y, size / 2, { restitution: 0.2, friction: 0.9, render: { fillStyle: color } });
      } else {
        body = Bodies.polygon(x, y, 3, size / 2, { restitution: 0.2, friction: 0.9, render: { fillStyle: color } });
      }

      body.isFalling = true;
      World.add(world, body);
      return body;
    }

    // ã‚¯ãƒªãƒƒã‚¯ã§è½ä¸‹
    window.addEventListener("click", (e) => {
      if (gameOver) return;
      createRandomShape(e.clientX, 50);
    });

    // å—ã‘çš¿ã®å·¦å³ç§»å‹•
    Events.on(engine, "afterUpdate", () => {
      if (paddle.position.x > WIDTH - paddleWidth / 2 || paddle.position.x < paddleWidth / 2) {
        moveDirection *= -1;
      }
      Body.setPosition(paddle, { x: paddle.position.x + moveDirection * moveSpeed, y: paddle.position.y });

      // è½ä¸‹ãƒŸã‚¹åˆ¤å®š
      world.bodies.forEach(body => {
        if (body.isFalling && body.position.y > HEIGHT) {
          World.remove(world, body);
          body.isFalling = false;
          misses++;
          document.getElementById("score").textContent = `ã‚¹ã‚³ã‚¢: ${score}ã€€ãƒŸã‚¹: ${misses}/${maxMisses}`;
          if (misses >= maxMisses) {
            gameOver = true;
            alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ğŸ˜¢");
          }
        }
      });
    });

    // è¡çªå‡¦ç†ï¼ˆå—ã‘çš¿ã¾ãŸã¯ä»–ã®å›³å½¢ã«ä¹—ã£ãŸã‚‰ä¸€ç·’ã«å‹•ãã‚ˆã†ã«ã™ã‚‹ï¼‰
    Events.on(engine, "collisionStart", (event) => {
      if (gameOver) return;

      event.pairs.forEach(pair => {
        const { bodyA, bodyB } = pair;

        const isPaddleCollision =
          (bodyA.isFalling && bodyB === paddle) || (bodyB.isFalling && bodyA === paddle);

        if (isPaddleCollision) {
          const fallingBody = bodyA.isFalling ? bodyA : bodyB;
          fallingBody.isFalling = false;

          // çš¿ã¨ã¤ãªãConstraintï¼ˆå¼¾æ€§ã‚ã‚Šï¼‰
          const joint = Constraint.create({
            bodyA: paddle,
            bodyB: fallingBody,
            pointA: { x: 0, y: -10 },
            pointB: { x: 0, y: 10 },
            stiffness: 0.002, // æŸ”ã‚‰ã‹ãã¤ãªã
            damping: 0.1
          });
          World.add(world, joint);

          score++;
          document.getElementById("score").textContent = `ã‚¹ã‚³ã‚¢: ${score}ã€€ãƒŸã‚¹: ${misses}/${maxMisses}`;
        }

        // ä»–ã®é™æ­¢ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸Šã«ä¹—ã£ãŸå ´åˆ
        const isBlockCollision =
          (bodyA.isFalling && bodyB.isStatic && bodyB !== ground) ||
          (bodyB.isFalling && bodyA.isStatic && bodyA !== ground);

        if (isBlockCollision) {
          const fallingBody = bodyA.isFalling ? bodyA : bodyB;
          fallingBody.isFalling = false;
          fallingBody.isStatic = true; // å›ºå®šåŒ–
          score++;
          document.getElementById("score").textContent = `ã‚¹ã‚³ã‚¢: ${score}ã€€ãƒŸã‚¹: ${misses}/${maxMisses}`;
        }
      });
    });
  </script>
</body>
</html>
